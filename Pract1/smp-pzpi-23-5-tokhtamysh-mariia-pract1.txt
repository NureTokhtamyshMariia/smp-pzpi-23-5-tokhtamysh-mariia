МІНІСТЕРСТВО ОСВІТИ I НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ

ЗВІТ
з практичної роботи №1
з дисципліни «Скриптові мови програмування»

Виконала                                                                 Перевірив:
ст. гр. ПЗПІ-23-5                                                        ст. викладач катедри ПІ
Тохтамиш Марія                                                           Сокорчук Ігор Петрович


Харків 2025


1 ІСТОРІЯ ЗМІН
№	   Дата	        Версія звіту	 Опис змін та виправлень
1	   15.05.2025 	  0.1	           Створено розділ «Завдання»
2	   20.05.2025 	  0.2	           Створено розділ «Опис виконаної роботи» та «Висновки».


2 ЗАВДАННЯ
	Написатати Bash скрипт, який друкуватиме на екрані ялинку із двох ярусів гілок, стовбура та шару снігу.
	Наприклад таку:

     *  
    ###  
   *****  
  #######  
 *********  
    ###  
   *****  
  #######  
 *********  
    ###  
    ###  
***********  
	Ялинка повинна бути симетричною.

	Яруси гілок повинні утворювати правильні рівнобедрені трикутники у яких сусідні рядки відрізняються на два символи та складаються почергово або з символів «*» або з символів «#» наприклад як такий:

    *  
   ###  
  *****  
 #######   
	Ширина усіх ярусів гілок повинна бути на 2 символи вужча ніж ширина снігу.

	Висота стовбура та товщина снігу мають бути завжди такі, як у прикладі.

	Висота ялинки у рядках разом з шаром снігу та ширина шару снігу в символах вказується скрипту в його параметрах при запуску.

	Параметри скрипта повинні мати додатнє значення.

	Вказані значення повинні округлятися до потрібних у меншу сторону.

	Якщо за вказаними при запуску скрипта значеннями зобразити ялинку на екрані неможливо, скрипт повинен вивести у потік помилок сповіщення про неправильне значення аргумента і повернути відповідний результат у батьківський процес.

	У скрипті потрібно обовʼязково використати такі конструкції:

if ... then ... fi  
while ... do ... done  
until ... do ... done  
for ... in .. do ... done  
for ((...)); do ... done  
У скрипті також потрібно використати функцію.  
Ім’я скрипта: ~/{імʼя-облікового-запису}-task1

	Приклад виклику скрипта: ~/pzpiz-26-7-shukhevych-roman-task1 16 11
	Файл скрипта повинен бути виконуваним файлом для усіх користуачів системи.
	Право редагувати файл скрипта повинен мати лише власник скрипта.


3 ОПИС ВИКОНАНОЇ РОБОТИ
Створюємо новий файл. 
	Почнемо з розгляду перших рядків Bash-скрипта, який очікує два аргументи: висоту ялинки та ширину нижнього шару "снігу". Щоб гарантувати коректну роботу програми, перед основною логікою необхідно перевірити, чи дотримано вимог до вхідних параметрів. Саме цим і займається наступний блок коду:

1.	if (( $# != 2 )); then
2.	    echo "Error: Expected exactly 2 arguments: height and snow_width." >&2
3.	    exit 1
4.	fi

	Тут перевіряється, чи користувач передав рівно два аргументи при виклику скрипта. Змінна $# містить кількість аргументів командного рядка. Якщо ця кількість не дорівнює двом, скрипт виводить повідомлення про помилку в стандартний потік помилок (через >&2) і завершує виконання з кодом 1, що означає помилку неправильного виклику. Така перевірка дозволяє уникнути непередбачуваної поведінки програми у випадку, якщо вхідні дані неповні або надмірні.

5.	if (( $1 < 8 )); then
6.	    echo "Error: Tree height must be at least 8." >&2
7.	    exit 2
8.	fi

	Цей фрагмент перевіряє, чи задана висота дерева (перший аргумент $1) є меншою за 8. Якщо це так, скрипт виводить повідомлення про помилку та завершує роботу з кодом 2. Мінімальна висота необхідна для коректного формування двоярусних гілок, стовбура та снігу.

9.	valid_height=$(( $1 / 2 * 2 ))
10.	min_snow=$(( valid_height - 1 ))
11.	max_snow=$(( valid_height ))
12.	if (( $2 < min_snow || $2 > max_snow )); then
13.	    echo "Error: Snow width must be either $min_snow or $max_snow for the given height $1." >&2
14.	    exit 3
15.	fi

	Змінна valid_height обчислюється як найбільше парне число, що не перевищує передане значення висоти $1. Це потрібно для збереження симетрії ялинки. Наприклад, якщо користувач ввів 9, то висота буде округлена до 8. Змінні min_snow та max_snow визначають допустимий діапазон для ширини снігу — вона може дорівнювати valid_height або бути на 1 менше. Якщо задана ширина снігу $2 не входить у дозволений діапазон, скрипт виводить повідомлення про помилку й завершується з кодом 3.

16.	TREE_HEIGHT=$(( $1 / 2 * 2 ))
17.	SNOW_WIDTH=$(( TREE_HEIGHT - 1 ))

	Тут знову обчислюється фактична парна висота дерева та ширина шару снігу. Висота зберігається у змінній TREE_HEIGHT, ширина снігу — у SNOW_WIDTH. Ширина снігу завжди на один символ менша за висоту дерева, що забезпечує гармонійний вигляд

18.	build_layer

Виклик функції build_layer, яка формує основну частину дерева — його гілки.

19.	build_layer() {
20.	    height=$(( (TREE_HEIGHT - 2) / 2 ))
21.	    row=1
22.	    sym="*"

	Функція build_layer оголошується без параметрів. У змінну height записується кількість рядків, які будуть використані для побудови кожного з двох ярусів гілок. Висота зменшується на 2, оскільки два останні рядки відводяться під стовбур і сніг. Змінна row ініціалізується значенням 1 і використовується як лічильник у циклі. Змінна sym встановлюється в * — це початковий символ, який буде використовуватись для побудови гілок.

23.	 while (( row <= height )); do
24.	        width=$(( row * 2 - 1 ))
25.	        print_row "$width" "$sym"
26.	        if [ "$sym" == "*" ]; then
27.	            sym="#"
28.	        else
29.	            sym="*"
30.	        fi
31.	        ((row++))
32.	done
	Цикл while будує верхній ярус гілок. У кожній ітерації обчислюється ширина рядка за формулою row * 2 - 1, що забезпечує поступове розширення трикутника. Функція print_row виводить рядок заданої ширини, заповнений символами * або #. Після кожного рядка символ змінюється на протилежний: якщо був *, стає #, і навпаки. Це створює чергування символів у гілках. Змінна row збільшується на 1 для переходу до наступного рядка.
33.	print_row() {
34.	    local width=$1
35.	    local symbol=$2
36.	    local padding=$(( ((SNOW_WIDTH - 2 - width) / 2) + 1 ))
37.	    printf "%${padding}s" ""
38.	    printf "%${width}s\n" | tr ' ' "$symbol"
39.	}
	Функція print_row призначена для виведення одного рядка дерева. Вона приймає два параметри: ширину рядка та символ, яким заповнюється рядок. Всередині функції обчислюється padding — кількість пробілів, необхідних для вирівнювання рядка по центру дерева. Спочатку виводиться задана кількість пробілів (padding), потім рядок із пробілів шириною width, у якому всі пробіли замінюються на заданий символ за допомогою команди tr. Завдяки цьому рядки гілок мають симетричне розміщення по центру ялинки.
Продовження логіки функції build_layer() 
40.	    row=2
41.	    until (( row > height )); do
42.	        width=$(( row * 2 - 1 ))
43.	        print_row "$width" "$sym"
44.	        if [ "$sym" == "*" ]; then
45.	            sym="#"
46.	        else
47.	            sym="*"
48.	        fi
49.	        ((row++))
50.	    done
51.	}
52.	
	Після побудови верхнього ярусу функція продовжує формувати нижній ярус гілок. Для цього використовується цикл until, який виконується, поки row не перевищить height. Початкове значення row = 2, оскільки перший рядок другого ярусу повинен бути ширшим, ніж останній рядок верхнього. У кожній ітерації знову обчислюється ширина рядка, викликається print_row, а символ гілки чергується між * і #. Цей блок повністю симетричний до попереднього, що дозволяє створити двоярусну структуру.
53.	trunk_height=2
54.	trunk_width=3
55.	trunk_padding=$(( (SNOW_WIDTH - trunk_width) / 2 ))

	Ці змінні використовуються для побудови стовбура дерева. trunk_height визначає кількість рядків у стовбурі (у цьому випадку — два рядки). trunk_width задає ширину кожного рядка стовбура (три символи). trunk_padding обчислює кількість пробілів зліва для центрування стовбура по ширині дерева.


56.	for (( i = 0; i < trunk_height; i++ )); do
57.	    printf "%${trunk_padding}s" ""
58.	    printf "%${trunk_width}s\n" | tr ' ' '#'
59.	done
Цикл for виводить рядки стовбура. У кожній ітерації спочатку друкується необхідна кількість пробілів зліва, потім виводиться рядок довжиною trunk_width, у якому пробіли замінюються символом #. Завдяки цьому стовбур розташовується строго посередині дерева і має постійну ширину.
60.	 printf "%${SNOW_WIDTH}s\n" | tr ' ' '*'

	Після побудови стовбура друкується один рядок, що представляє сніг. Його ширина дорівнює SNOW_WIDTH, яка була задана як один із параметрів. Рядок формується з пробілів, які замінюються символом *, і розташовується під стовбуром.
 

4 ВИСНОВКИ
   Під час виконання лабораторної роботи я набула практичних навичок роботи з Bash-скриптами для обробки текстових файлів, зокрема CSV-формату. Я навчилася використовувати команди select, awk, sort, uniq, sed, iconv та інші для автоматизації вибору файлів, обробки розкладу занять та формування даних у формат, сумісний із Google Календарем. Особливу увагу було приділено роботі з текстовими кодуваннями, перетворенню дат і часу, а також обробці помилок, що покращило моє розуміння роботи системних команд у Linux. 


ДОДАТОК А
Відеозапис


