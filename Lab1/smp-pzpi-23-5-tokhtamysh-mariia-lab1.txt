Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Катедра програмної інженерії

ЗВІТ
з лабораторної роботи №1
з дисципліни «Скриптові мови програмування»

Виконала
ст. гр. ПЗПІ-23-5
Тохтамиш Марія

Перевірив
ст. викладач катедри ПІ
Сокорчук Ігор Петрович

Харків 2025


1 ІСТОРІЯ ЗМІН
№	   Дата	        Версія звіту	 Опис змін та виправлень
1	   16.05.2025 	0.1	           Створено розділ «Завдання», «Опис виконаної роботи» та «Висновки».


2 ЗАВДАННЯ
- Розробити Bash-скрипт, який перетворює CSV-файл розкладу занять, експортований із сайту https://cist.nure.ua, у формат CSV, придатний для імпорту в Google Календар.
- Скрипт повинен:
1. Мати ім’я: ~/{імʼя-облікового-запису}-task2
2. Підтримувати запуск у форматі:
   {імʼя-облікового-запису}-task2 [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]
3. У разі відсутності параметрів:
   - Використовувати select для вибору CSV-файлу з шаблоном TimeTable_??_??_20??.csv (файли мають бути відсортовані за датою);
   - Відкрити обраний файл, зчитати академічні групи, відсортувати їх (за допомогою sort, uniq) та запропонувати вибір через select.
4. Обробляти CSV-файл:
   - Обрати записи лише для вказаної (або вибраної) академічної групи;
   - Визначити порядкові номери занять, враховуючи, що лабораторні = 2 пари, решта = 1;
   - Очистити поле «Subject» від префіксу з назвою групи;
   - Додати номер заняття до теми (після крапки з комою);
   - Перетворити дату і час у формат: mm/dd/yyyy, HH:MM AM|PM;
   - У полі Description зберегти текст з поля «Опис (Описание)»;
   - Вивести результат у stdout (якщо не вказано -q|--quiet) та зберегти до файлу Google_TimeTable_??_??_20??.csv
5. Підтримувати ключі:
   --help       — виводить довідку;
   --version    — виводить версію;
   -q|--quiet   — не виводить дані в консоль.
6. У разі помилки:
   - Повідомляти у stderr;
   - Повернути ненульовий код завершення;
   - Якщо група не знайдена — запропонувати вибрати іншу;
   - Якщо у файлі лише одна група — обробити її автоматично.
7. Мати обов’язкові Bash-конструкції:
   - if ... then ... fi
   - while ... do ... done
   - for ... in ... do ... done
   - case ... in ... esac
8. Обов’язково використати команди:
   select, ls, awk, sort, uniq, tee, cat, sed, iconv
9. Результат — CSV-файл із полями:
   Subject, Start date, Start time, End date, End time, Description
   — готовий для імпорту в Google Календар.


3 ОПИС ВИКОНАНОЇ РОБОТИ
  Створюємо новий файл відповідно до формату ~/{ім?я-облікового-запису}-task2.
У нашому випадку отримуємо назву: pzpi-23-5-tokhtamysh-mariia-task2.
Після входу в систему виконуємо команду: «hostname», що дозволяє отримати назву хоста, на якому виконується сеанс.

  Додаємо файл із розкладом потоку ПЗПІ на сервер, використовуючи команду у звичайний командний рядок:  
scp TimeTable_20_03_2025.csv pzpi-23-5-tokhtamysh mariia@vps52766.hyperhost.name:/home/pzpi-23-5-tokhtamysh-mariia/

  Після виконання цієї команди система запитає введення пароля користувача. Після успішного введення пароля файл буде переданий на сервер у вказану директорію. Щоб переконатися, що файл дійсно було завантажено, виконується команда ls ~. Вона виводить список файлів і папок у домашній директорії користувача. Серед них є TimeTable_20_03_2025.csv, це означає, що передача файлу пройшла успішно.

     На самому початку скрипт перевіряє, чи були передані два аргументи при запуску — назва академічної групи та файл розкладу. Якщо так, то ці значення зберігаються в змінні. Якщо передано перший і другий параметр, то перший з них записується у змінну selected_group (це назва академічної групи), а другий — у selected_file (це CSV-файл з розкладом). Потім перевіряється, чи існує файл, шлях до якого збережено в selected_file. Тобто перевіряється фактична наявність файлу на диску. Якщо ні — скрипт виводить повідомлення про помилку і припиняє роботу
     
1. if [[ -n "$1" && -n "$2" ]]; then
2. selected_group="$1"
3. selected_file="$2"
4. if [[ ! -f "$selected_file" ]]; then
5. echo "Error: File '$selected_file' not found!"
6. exit 1
7. fi

     Якщо ж аргументів немає, або передано тільки один аргумент, або перший аргумент починається з дефіса. Тут перевірка [[ "$1" =~ - ]] використовується для того, щоб визначити, чи містить перший аргумент дефіс. Якщо так, скрипт сприймає це як групу (наприклад, ПЗПІ-23-1) і продовжує виконання з пошуку файлів, що містять відповідний розклад для цієї групи. Тоді скрипт виконує пошук CSV-файлів з розкладом у домашній директорії. Він формує масив files, куди записуються всі файли, що відповідають шаблону TimeTable_??_??_20??.csv

8. else
9. if [ -z "$1" ] || [[ "$1" =~ - ]]; then
10. files=( $(ls "$HOME"/TimeTable_??_??_20??.csv 2>/dev/null) )
11. if [[ ${#files[@]} -eq 0 ]]; then
12. echo "Files not found."
13. exit 1
14. fi

     Якщо файли знайдені, користувачу пропонується обрати один із них за допомогою конструкції select, яка автоматично формує нумероване меню. Можна також обрати "Quit", щоб вийти.

15. echo "Select a file (or type 'Quit' to exit):"
16. select file in "${files[@]}" "Quit"; do
17. if [[ "$file" == "Quit" ]]; then
18. echo "Exiting..."
19. exit 0
20. elif [[ -n "$file" ]]; then
21. selected_file="$file"
22. break
23. else
24. echo "Invalid choice, please try again."
25. fi
26. done

     Якщо ж передано лише файл, без групи, то цей файл призначається змінній selected_file, а інші параметри зміщуються (через shift).

27. else
28. selected_file="$1"
29. shift
30. fi
31. fi

     Далі скрипт перевіряє, чи шлях до файлу є абсолютним (тобто починається з /). Якщо ні — додає до нього домашню директорію, створюючи повний шлях. Це потрібно, щоб не було проблем із відносними шляхами — скрипт автоматично формує коректний повний шлях до файлу.

32.if [[ ! "$selected_file" =~ ^/ ]]; then
33. selected_file="$HOME/$selected_file"
34. fi

Ще раз перевіряється, чи існує файл, і якщо ні — скрипт знову завершується.

35. if [[ ! -f "$selected_file" ]]; then
36. echo "Error: File '$selected_file' not found!"
37. exit 1
38. fi

     Файл конвертується з кодування Windows-1251 (типове для CIST) у UTF-8 і записується у тимчасовий файл. Також символ \r перетворюється на \n, щоб розділити рядки коректно.

39. tmp_path="/tmp/$(basename "$selected_file")"
40. iconv -f WINDOWS-1251 -t UTF-8 "$selected_file" | tr '\r' '\n' > "$tmp_path"

     Тепер з цього тимчасового файлу шукаються всі унікальні назви академічних груп, які мають у розкладі мітку DL [назва групи]. Цей текст спочатку видобувається через grep, потім обробляється через sed, фільтрується (grep -v ','), сортується (sort) і залишаються лише унікальні значення (uniq).

41. INPUT_FILE="$tmp_path"
42. groups=$(grep -o '"[^"]*DL [А-Яа-я0-9,-]\+[^\"]*"' "$INPUT_FILE" | sed -E 's/.*DL ([А-Яа-я0-9,-]+).*$/\1/g' | grep -v ',' | sort | uniq)

     Далі скрипт виводить знайдені групи:

43. echo "Found groups in the file:"
44. echo "$groups"

     Якщо груп не знайдено, скрипт завершує виконання:

45. if [[ -z "$groups" ]]; then
46. echo "No groups found in the file."
47. exit 1
48. fi

     Якщо групу не було передано як аргумент, користувач обирає її зі списку через select:

49. if [ -z "$1" ]; then
50. echo "Select a group (or type 'Quit' to exit):"
51. select selected_group in $groups "Quit"; do
52. if [[ "$selected_group" == "Quit" ]]; then
53. echo "Exiting..."
54. exit 0
55. elif [[ -n "$selected_group" ]]; then
56. break
57. else
58. echo "Invalid choice, please try again."
59. fi
60. done

     А якщо групу передано як аргумент, скрипт перевіряє, чи вона є серед знайдених:

61. else
62. selected_group=$1
63. if ! grep -q "$selected_group" <<< "$groups"; then
64. echo "Error: Group '$selected_group' not found in the file!"
65. exit 1
66. fi
67. fi

     Далі створюється фінальний CSV-файл із заголовками колонок, який відповідатиме формату Google Calendar:

68. OUTPUT_FILE="$HOME/Google_$(basename "$selected_file")"
69. echo "group: $selected_group"
70. echo "Input file: $INPUT_FILE"
71. echo "Output file: $OUTPUT_FILE"

72.echo "\"Subject\",\"Start Date\",\"Start Time\",\"End Date\",\"End Time\",\"Description\"" > "$OUTPUT_FILE"

     Тепер основна обробка відбувається через awk. Створюється асоціативний масив subject_count, який буде використовуватись для нумерації кожного предмета в розкладі. Це потрібно для того, щоб уникнути дублювання предметів у кінцевому CSV-файлі та додавати номер до кожного заняття, якщо таких занять кілька.
     
73. declare -A subject_count

     Далі використовується команду awk для обробки CSV-файлу. Передаємо змінну selected_group в awk, що дозволяє фільтрувати дані по вибраній групі. У awk задається параметр FPAT, який визначає, як розпізнавати поля в файлі, враховуючи можливі подвійні лапки в значеннях. Задається також роздільник полів для виводу результату через OFS.

74. awk -v group="$selected_group" 'BEGIN {
75. FPAT = "([^,]+)|(\"[^\"]+\")"
76. OFS = ","
77. }

     Наступним кроком йде перевірка кожного рядка в файлі. Перша перевірка NR > 1 дозволяє пропустити перший рядок, який є заголовком. Далі виконується цикл по всіх полях кожного рядка, і для кожного поля прибираються подвійні лапки за допомогою функцій sub.

78. NR > 1 {
79. for(i = 1; i <= NF; i++) {
80. sub(/^\"/, "", $i)
81. sub(/\"$/, "", $i)
82. }

     Після цього виконується перевірка, чи належить поточний рядок до обраної групи, що визначається за допомогою регулярного виразу. Перше поле (номер групи) має починатися з назви групи, яку передано як параметр group.
     
83. if ($1 ~ "^" group " -") {

     Якщо рядок відповідає умові, з нього витягується назва предмета, яка зберігається в 12-му стовпці. Далі, збільшується лічильник для цього предмета в масиві subject_count, щоб нумерувати кожне заняття для цього предмета (якщо таких предметів кілька).
     
84. subject=$12
85. subject_count[subject]++
86. numbered_subject = subject "; №" subject_count[subject]

     Задаються змінні для дати та часу початку й кінця заняття. Дата з розкладу спочатку розбивається на частини (день, місяць, рік) за допомогою функції split, і потім форматуються у формат місяць/день/рік.
     
87. start_date = $2
88. end_date = $4
89. split(start_date, start_arr, ".")
90. start_date = start_arr[2] "/" start_arr[1] "/" start_arr[3]
91. split(end_date, end_arr, ".")
92. end_date = end_arr[2] "/" end_arr[1] "/" end_arr[3]

     Аналогічно розбивається час початку та кінця заняття. Виходячи з 24-годинного формату часу, час перетворюється у 12-годинний формат з AM/PM, коригується година та хвилини, після чого форматується у вигляді година:хвилина AM/PM.
     
93. split(start_time, start_time_arr, ":")
94. start_hour = start_time_arr[1]
95. start_minute = start_time_arr[2]
96. start_ampm = (start_hour >= 12 && start_hour < 24) ? "PM" : "AM"
97. if (start_hour > 12) { start_hour -= 12 }
98. if (start_hour == 0) { start_hour = 12 }
99. start_time = start_hour ":" start_minute " " start_ampm
     
100. split(end_time, end_time_arr, ":")
101. end_hour = end_time_arr[1]
102. end_minute = end_time_arr[2]
103. end_ampm = (end_hour >= 12 && end_hour < 24) ? "PM" : "AM"
104. if (end_hour > 12) { end_hour -= 12 }
105. if (end_hour == 0) { end_hour = 12 }
106. end_time = end_hour ":" end_minute " " end_ampm

     На завершення виводяться всі необхідні дані у вигляді CSV-запису, де кожен рядок містить відформатовані дані про предмет, дату та час початку й закінчення заняття, а також групу. Для кожного заняття додається номер до назви предмета, якщо таких занять кілька.
     
107. print "\"" numbered_subject "\"","\"" start_date "\"","\"" start_time "\"","\"" end_date "\"","\"" end_time "\"","\"" group "\""

     Виведення результату записується у вихідний файл, який містить усі необхідні дані для імпорту в Google Календар.
     
108. }' "$INPUT_FILE" >> "$OUTPUT_FILE"


4 ВИСНОВКИ
  Під час виконання лабораторної роботи я набула практичних навичок роботи з Bash-скриптами для обробки текстових файлів, зокрема CSV-формату. Я навчилася використовувати команди select, awk, sort, uniq, sed, iconv та інші для автоматизації вибору файлів, обробки розкладу занять та формування даних у формат, сумісний із Google Календарем. Особливу увагу було приділено роботі з текстовими кодуваннями, перетворенню дат і часу, а також обробці помилок, що покращило моє розуміння роботи системних команд у Linux. 

