МІНІСТЕРСТВО ОСВІТИ I НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ

ЗВІТ
з лабораторної роботи №1
з дисципліни «Скриптові мови програмування»

Виконала                                                                 Перевірив:
ст. гр. ПЗПІ-23-5                                                        ст. викладач катедри ПІ
Тохтамиш Марія                                                           Сокорчук Ігор Петрович


Харків 2025


1 ІСТОРІЯ ЗМІН
№	   Дата	        Версія звіту	 Опис змін та виправлень
1	   16.05.2025 	0.1	           Створено розділ «Завдання», «Опис виконаної роботи» та «Висновки».


2 ЗАВДАННЯ
- Розробити Bash-скрипт, який перетворює CSV-файл розкладу занять, експортований із сайту https://cist.nure.ua, у формат CSV, придатний для імпорту в Google Календар.
- Скрипт повинен:
1. Мати ім’я: ~/{імʼя-облікового-запису}-task2
2. Підтримувати запуск у форматі:
   {імʼя-облікового-запису}-task2 [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]
3. У разі відсутності параметрів:
   - Використовувати select для вибору CSV-файлу з шаблоном TimeTable_??_??_20??.csv (файли мають бути відсортовані за датою);
   - Відкрити обраний файл, зчитати академічні групи, відсортувати їх (за допомогою sort, uniq) та запропонувати вибір через select.
4. Обробляти CSV-файл:
   - Обрати записи лише для вказаної (або вибраної) академічної групи;
   - Визначити порядкові номери занять, враховуючи, що лабораторні = 2 пари, решта = 1;
   - Очистити поле «Subject» від префіксу з назвою групи;
   - Додати номер заняття до теми (після крапки з комою);
   - Перетворити дату і час у формат: mm/dd/yyyy, HH:MM AM|PM;
   - У полі Description зберегти текст з поля «Опис (Описание)»;
   - Вивести результат у stdout (якщо не вказано -q|--quiet) та зберегти до файлу Google_TimeTable_??_??_20??.csv
5. Підтримувати ключі:
   --help       — виводить довідку;
   --version    — виводить версію;
   -q|--quiet   — не виводить дані в консоль.
6. У разі помилки:
   - Повідомляти у stderr;
   - Повернути ненульовий код завершення;
   - Якщо група не знайдена — запропонувати вибрати іншу;
   - Якщо у файлі лише одна група — обробити її автоматично.
7. Мати обов’язкові Bash-конструкції:
   - if ... then ... fi
   - while ... do ... done
   - for ... in ... do ... done
   - case ... in ... esac
8. Обов’язково використати команди:
   select, ls, awk, sort, uniq, tee, cat, sed, iconv
9. Результат — CSV-файл із полями:
   Subject, Start date, Start time, End date, End time, Description
   — готовий для імпорту в Google Календар.


3 ОПИС ВИКОНАНОЇ РОБОТИ
 Створюємо новий файл. 
     Відкриваємо термінал Bash і переходимо робочу директорію. У нашому випадку це папка на робочому столі, і ми використовуємо команду cd ~/Desktop/ЛАБ_1_Mariia_Tokhtamysh, щоб потрапити в неї. Сам скрипт має назву pzpi-23-5-tokhtamysh-mariia-task2.sh і служить для обробки CSV-файлів з розкладом занять. У самій папці вже є підготовлені файли із розкладом завантажені з сайту cist.nure.ua
     Функція main є точкою входу у скрипт. Кожна частина виконує окрему логічну задачу, що разом забезпечує коректне опрацювання вхідних параметрів, обробку файлів і генерацію результату. 
       
1. script_dir="$(cd "$(dirname "$0")" && pwd)"

     Цей рядок визначає повний шлях до директорії, де знаходиться сам скрипт. Для цього спочатку визначається директорія файлу скрипта за допомогою dirname "$0", потім виконується перехід у цю директорію (cd), а команда pwd повертає абсолютний шлях. Це потрібно, щоб коректно працювати з файлами у тій же папці незалежно від того, звідки запущено скрипт.

2. if [[ -n "$1" && -n "$2" ]]; then
3.   selected_group="$1"
4.   selected_file="$2"
5.   [[ "$selected_file" != /* ]] && selected_file="$script_dir/$selected_file"
6. else
7.   if [ -z "$1" ] || [[ "$1" =~ - ]]; then
8.     select_timetable_file
9.   else
10. selected_file="$1"
11.     shift
12.   fi
13. fi
       
     Цей блок перевіряє, чи передано у виклик скрипта два аргументи. Якщо так, то перший аргумент призначається як вибрана група, другий — як файл розкладу. Якщо шлях до файлу не абсолютний (не починається з /), він доповнюється директорією скрипта.
     Якщо аргументи не передані, або перший аргумент є опцією (починається з -), викликається функція вибору файлу розкладу select_timetable_file. Якщо ж передано тільки один аргумент, він вважається шляхом до файлу, а змінна $1 звільняється для подальшого використання.
       
14. [[ "$selected_file" != /* ]] && selected_file="$script_dir/$selected_file"
     
     Цей рядок повторно перевіряє, чи є шлях до файлу абсолютним. Якщо ні, доповнює шлях директорією скрипта. Це потрібно, щоб бути впевненим у коректності шляху до файлу.

15. if [[ ! -f "$selected_file" ]]; then
16.   echo "Error: File '$selected_file' not found!"
17.   exit 1
18. fi

     Перевіряється, чи існує файл за вказаним шляхом. Якщо файлу немає, виводиться повідомлення про помилку і скрипт завершує роботу з кодом помилки

19. source_csv="$selected_file"
20. converted_file="/tmp/converted_$(basename "$source_csv")"
21. convert_encoding

     Встановлюється змінна source_csv як шлях до вхідного файлу, а converted_file — тимчасовий файл у /tmp для результату конвертації кодування. Викликається функція convert_encoding, яка виконує перетворення кодування з Windows-1251 у UTF-8.

22. convert_encoding() {
23.   local enc_src="WINDOWS-1251"
24.   local enc_dst="UTF-8"
25.   iconv -f "$enc_src" -t "$enc_dst" "$source_csv" > "$converted_file"
26.   sed -i 's/\r/\n/g' "$converted_file"
27. }

	Функція convert_encoding відповідає за зміну кодування вхідного CSV-файлу з WINDOWS-1251 на UTF-8. Спочатку визначаються змінні, які містять назви вихідного та цільового кодувань. Далі за допомогою утиліти iconv виконується конвертація файлу з одного кодування в інше, результат записується у тимчасовий файл. Після цього команда sed замінює символи повернення каретки (Windows-стиль кінця рядка) на символи нового рядка, що забезпечує коректне відображення рядків у файлі з новим кодуванням. Такий підхід дозволяє уніфікувати формат тексту та підготувати файл для подальшої обробки.


28. INPUT_FILE="$converted_file"
29. extract_groups || { echo "No valid groups found!"; exit 1; }

	Встановлюється змінна INPUT_FILE як шлях до сконвертованого файлу. Потім виконується функція extract_groups, яка витягує список груп із файлу. Якщо ця функція повертає помилку (наприклад, груп не знайдено), виводиться повідомлення і скрипт завершується.

30. extract_groups() {
31.   local tmp_file="tmp_groups.csv"
32.   sed '1d; s/^\"[[:space:]]*\([^ ]*\).*$/\1/' "$INPUT_FILE" > "$tmp_file"
33.   [[ ! $(head -n 1 "$tmp_file") =~ "-" ]] && return 1
34.   sort "$tmp_file" | uniq > sorted.csv && mv sorted.csv "$tmp_file"
35.   mv "$tmp_file" .group_list
36.   return 0
37. }

	Функція extract_groups відповідає за вилучення списку груп із вхідного CSV-файлу. Спочатку створюється тимчасовий файл, куди записуються результати обробки основного файлу. Команда sed видаляє перший рядок (зазвичай заголовок) та за допомогою регулярного виразу витягує назви груп із початку рядка, виділяючи перший фрагмент тексту до першого пробілу. 
	Далі перевіряється, чи перший рядок тимчасового файлу містить символ «-», який вказує на правильний формат назви групи. Якщо ця умова не виконується, функція повертає помилку. Після цього тимчасовий файл сортується і дублікати видаляються за допомогою команд sort та uniq, результат знову записується у тимчасовий файл. Наприкінці тимчасовий файл перейменовується у файл .group_list, що містить унікальний перелік груп для подальшого використання. Функція завершується з кодом успішного виконання.

38. groups=$(cat .group_list)
39. echo "Found groups in the file:"
40. echo "$groups"
41. if [[ -z "$groups" ]]; then
42.    echo "No groups found in the file."
43.     exit 1
44. fi

	Зчитується список груп з тимчасового файлу .group_list. Виводиться повідомлення з переліком знайдених груп. Якщо список порожній, виводиться помилка і скрипт завершує роботу.

45. if [[ -z "$selected_group" ]]; then
46.   select_group
47. else
48.   if ! grep -q "$selected_group" <<< "$groups"; then
49.     echo "Error: Group '$selected_group' not found in the file!"
50.     exit 1
51.   fi
52. Fi

	Якщо група не була передана як аргумент, викликається функція select_group для вибору групи користувачем. Якщо група вже вибрана, перевіряється, чи є вона у списку знайдених груп. Якщо групи немає у списку, виводиться помилка і робота припиняється.

53. select_group() {
54.   echo "Select a group (or type 'Quit' to exit):"
55.   select selected_group in $groups "Quit"; do
56.     if [[ "$selected_group" == "Quit" ]]; then
57.       echo "Exiting..."
58.       exit 0
59.     elif [[ -n "$selected_group" ]]; then
60.       break
61.     else
62.       echo "Invalid choice, please try again."
63.     fi
64.   done
65. }

	Функція select_group відповідає за вибір групи користувачем із наявного списку. Вона виводить на екран запрошення обрати групу або вийти з програми, ввівши "Quit". Використовується конструкція select, яка створює меню з доступних груп, а також опції "Quit". Якщо користувач вибирає "Quit", скрипт виводить повідомлення про вихід і завершує роботу з кодом 0. Якщо вибір є дійсним (непорожнім), цикл припиняється і вибрана група зберігається для подальшого використання. У випадку недійсного вибору виводиться повідомлення про помилку, і користувача знову просять зробити вибір. Таким чином функція забезпечує інтуїтивний і безпечний спосіб вибору групи.

66. OUTPUT_FILE="$script_dir/Google_$(basename "$selected_file")"
67. echo "group: $selected_group"
68. echo "Input file: $INPUT_FILE"
69. echo "Output file: $OUTPUT_FILE"
70. generate_output_csv

	Формується ім’я вихідного файлу, який буде створено з префіксом Google_ у директорії скрипта. Виводяться параметри вибраної групи, вхідного та вихідного файлів для інформування користувача. Після цього запускається функція generate_output_csv, яка генерує кінцевий CSV-файл для подальшого використання.
	Функція generate_output_csv відповідає за створення вихідного CSV-файлу з розкладом у потрібному форматі. Спочатку у файл записується заголовок із назвами колонок: предмет, дата початку, час початку, дата кінця, час кінця та опис.
	Далі оголошується асоціативний масив для підрахунку кількості занять з кожного предмету, що дозволяє нумерувати повторювані предмети.
За допомогою команди awk здійснюється обробка вхідного файлу. У цьому блоці встановлюється патерн розбиття рядка на поля, який коректно розпізнає значення, навіть якщо вони взяті в лапки. Пропускається перший рядок, оскільки він містить заголовки.
	Для кожного рядка видаляються початкові та кінцеві лапки з полів. Якщо перше поле починається з назви вибраної групи, то обробляється інформація про заняття: витягується назва предмету, підраховується кількість його появ, і формується унікальна назва з номером.
	Дати початку і кінця переформатовуються зі стандартного формату дд.мм.рррр у формат мм/дд/рррр, який потрібен для сумісності з іншими системами.
	Часи початку і кінця конвертуються з 24-годинного формату в 12-годинний із позначками AM або PM. При цьому враховуються випадки півночі і полудня.
Всі оброблені дані формуються у рядок CSV і додаються до вихідного файлу.
Після завершення запису виводиться повідомлення про успішне створення файлу з вказанням його шляху.


4 ВИСНОВКИ
  Під час виконання лабораторної роботи я набула практичних навичок роботи з Bash-скриптами для обробки текстових файлів, зокрема CSV-формату. Я навчилася використовувати команди select, awk, sort, uniq, sed, iconv та інші для автоматизації вибору файлів, обробки розкладу занять та формування даних у формат, сумісний із Google Календарем. Особливу увагу було приділено роботі з текстовими кодуваннями, перетворенню дат і часу, а також обробці помилок, що покращило моє розуміння роботи системних команд у Linux. 

