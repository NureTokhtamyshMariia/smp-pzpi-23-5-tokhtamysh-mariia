МІНІСТЕРСТВО ОСВІТИ I НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ

ЗВІТ
з лабораторної роботи №1
з дисципліни «Скриптові мови програмування»

Виконала                                                                 Перевірив:
ст. гр. ПЗПІ-23-5                                                        ст. викладач катедри ПІ
Тохтамиш Марія                                                           Сокорчук Ігор Петрович


Харків 2025


1 ІСТОРІЯ ЗМІН
№	   Дата	        Версія звіту	 Опис змін та виправлень
1	   16.05.2025 	0.1	           Створено розділ «Завдання», «Опис виконаної роботи» та «Висновки».


2 ЗАВДАННЯ
Розробити Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар https://support.google.com/.
Вимоги до скрипта
Ім’я скрипта:
~/{імʼя-облікового-запису}-task2
Синтаксис виклику:
{імʼя-облікового-запису}-task2 [--help | --version] | [[-q|--quiet] [академ_група] файл_із_cist.csv]
Приклад виклику:
pzpi-23-12-koval-vasyl-task2 'ПЗПІ-23-12' TimeTable_15_03_2025.csv
Ключі:
•	--help — вивести довідку, завершити роботу та повернути успішний результат у батьківський процес
•	--version — вивести інформацію про версію, завершити роботу та повернути успішний результат у батьківський процес
•	-q або --quiet — не виводити інформацію в стандартний потік виведення
Параметри:
•	академ_група — назва академічної групи (шаблон)
•	файл_із_cist.csv — експортований CSV файл розкладу занять
Якщо при виклику скрипта не вказана академічна група або вхідний CSV файл, то скрипт повинен:
1.	Вивести меню вибору файла за допомогою команди select та сформувати відсортований за датою в іменах файлів (від старіших до новіших) список доступних у поточній директорії CSV файлів за шаблоном:
TimeTable_??_??_20??.csv
2.	Відкрити вибраний CSV файл та згенерувати список академічних груп, що містяться у файлі, відсортувати їх за алфавітом (sort, uniq) та вивести меню вибору групи за допомогою select.
Обробка файла:
1.	Читати вхідний CSV файл та вибирати рядки, що відповідають вибраній академічній групі.
2.	Визначити порядкий номер для кожного заняття (лекція, практичне заняття, лабораторна робота) із врахуванням того, що лабораторні роботи складаються із двох пар, а решта занять — із однієї пари.
3.	Створити поле «Subject» із поля «Тема» вхідного CSV файла, але БЕЗ назви академічної групи та дефіса на початку цього поля ("ПЗПІ-23-1 - ПрПА Пз DL ПЗПІ-23-1")
4.	Додати порядковий номер наприкінці теми (Subject) кожного заняття після крапки з комою (опис заняття; №1)
5.	Переформатувати дату та час до формату «mm/dd/yyyy, HH:MM AM|PM,» Gogle Календаря 12-годинний формат часу. Наприклад: 02/30/2025, 11:15 AM,
6.	Заповнити поле «Description» текстом із поля «Опис (Описание)» вхідного CSV файла
7.	Відформатувати дані відповідно до вимог Google Календаря https://support.google.com/calendar/.
8.	Виводити створені для Google Календаря дані у стандартний потік виведення, якщо це не заблоковано ключем -q або --quiet
9.	Записати результат у новий файл із назвою:
Google_TimeTable_??_??_20??.csv
де ??_??_20?? — дата, що відповідає вхідному файлу.
Обробка помилок:
•	Якщо файл не знайдено або файл є недоступним для читання, вивести повідомлення про помилку в стандартний потік помилок та повернути код помилки.
•	Якщо група не знайдена у вибраному файлі, повідомити про це користувача та запропонувати вибір іншої групи.
•	Якщо група не вказана, але у вказаному файлі присутня лише одна група, створити CSV файл Google Календаря для цієї групи.
•	Якщо сталася помилка під час обробки файла, повідомити про це та завершити роботу з відповідним кодом помилки.

Команди, які рекомендується використати у скрипті:
•	select — створення меню вибору файла та групи
•	ls — отримання списку доступних CSV файлів
•	awk — фільтрація та обробка даних CSV файла
•	sort — сортування даних (груп, дат тощо)
•	uniq — усунення дублікатів у списку груп
•	tee — збереження вихідних даних у файл та вивід на екран
•	cat — перегляд вмісту файла
•	sed — видалення зайвих пробілів, форматування дат, заміна символів
•	iconv — перетворення кодування файлів (Windows-1251 → UTF-8)
Результат роботи скрипта:
•	При виконанні скрипта створюється CSV файл, готовий для імпорту в Google Календар.
•	Послідовність полів у CSV файлі: Subject, Start date, Start time, End date, End time, Description
•	Файл містить коректно відформатовані дані про розклад занять для вибраної академічної групи.

Додаткові вимоги до скрипта:
	Скрипт має необхідні права доступу:
	Файл скрипта виконуваний для всіх користувачів
	Редагування файла скрипта дозволене лише власнику файла


3 ОПИС ВИКОНАНОЇ РОБОТИ
 Створюємо новий файл. 
     Відкриваємо термінал Bash і переходимо робочу директорію. У нашому випадку це папка на робочому столі, і ми використовуємо команду cd ~/Desktop/ЛАБ_1_Mariia_Tokhtamysh, щоб потрапити в неї. Сам скрипт має назву pzpi-23-5-tokhtamysh-mariia-task2.sh і служить для обробки CSV-файлів з розкладом занять. У самій папці вже є підготовлені файли із розкладом завантажені з сайту cist.nure.ua
     Функція main є точкою входу у скрипт. Кожна частина виконує окрему логічну задачу, що разом забезпечує коректне опрацювання вхідних параметрів, обробку файлів і генерацію результату. 

1 script_dir="$(cd "$(dirname "$0")" && pwd)"

     Цей рядок визначає повний шлях до директорії, де знаходиться сам скрипт. Для цього спочатку визначається директорія файлу скрипта за допомогою dirname "$0", потім виконується перехід у цю директорію (cd), а команда pwd повертає абсолютний шлях. Це потрібно, щоб коректно працювати з файлами у тій же папці незалежно від того, звідки запущено скрипт.

111 if [[ -n "$1" && -n "$2" ]]; then
112  selected_group="$1"
113  selected_file="$2"
114  [[ "$selected_file" != /* ]] && selected_file="$script_dir/$selected_file"
115 else
116 if [ -z "$1" ] || [[ "$1" =~ - ]]; then
117  select_timetable_file
118 else
119 selected_file="$1"
120  shift
121 fi
122 fi
       
     Цей блок перевіряє, чи передано у виклик скрипта два аргументи. Якщо так, то перший аргумент призначається як вибрана група, другий — як файл розкладу. Якщо шлях до файлу не абсолютний (не починається з /), він доповнюється директорією скрипта.
     Якщо аргументи не передані, або перший аргумент є опцією (починається з -), викликається функція вибору файлу розкладу select_timetable_file. Якщо ж передано тільки один аргумент, він вважається шляхом до файлу, а змінна $1 звільняється для подальшого використання.

134 if [[ ! -f "$selected_file" ]]; then
135  echo "Error: File '$selected_file' not found!"
136  exit 1
137 fi

     Перевіряється, чи існує файл за вказаним шляхом. Якщо файлу немає, виводиться повідомлення про помилку і скрипт завершує роботу з кодом помилки

139 source_csv="$selected_file"
140 converted_file="/tmp/converted_$(basename "$source_csv")"
141 convert_encoding

     Встановлюється змінна source_csv як шлях до вхідного файлу, а converted_file — тимчасовий файл у /tmp для результату конвертації кодування. Викликається функція convert_encoding, яка виконує перетворення кодування з Windows-1251 у UTF-8.

3 convert_encoding() {
4 local enc_src="WINDOWS-1251"
5 local enc_dst="UTF-8"
6 iconv -f "$enc_src" -t "$enc_dst" "$source_csv" > "$converted_file"
7 sed -i 's/\r/\n/g' "$converted_file"
8 }


	Функція convert_encoding відповідає за зміну кодування вхідного CSV-файлу з WINDOWS-1251 на UTF-8. Спочатку визначаються змінні, які містять назви вихідного та цільового кодувань. Далі за допомогою утиліти iconv виконується конвертація файлу з одного кодування в інше, результат записується у тимчасовий файл. Після цього команда sed замінює символи повернення каретки (Windows-стиль кінця рядка) на символи нового рядка, що забезпечує коректне відображення рядків у файлі з новим кодуванням. Такий підхід дозволяє уніфікувати формат тексту та підготувати файл для подальшої обробки.

143 INPUT_FILE="$converted_file"
144 extract_groups || { echo "No valid groups found!"; exit 1; }

	Встановлюється змінна INPUT_FILE як шлях до сконвертованого файлу. Потім виконується функція extract_groups, яка витягує список груп із файлу. Якщо ця функція повертає помилку (наприклад, груп не знайдено), виводиться повідомлення і скрипт завершується.

10 extract_groups() {
11 local tmp_file="tmp_groups.csv"
12 sed '1d; s/^\"[[:space:]]*\([^ ]*\).*$/\1/' "$INPUT_FILE" > "$tmp_file"
13 [[ ! $(head -n 1 "$tmp_file") =~ "-" ]] && return 1
14 sort "$tmp_file" | uniq > sorted.csv && mv sorted.csv "$tmp_file"
15 mv "$tmp_file" .group_list
16 return 0
17 }

	Функція extract_groups відповідає за вилучення списку груп із вхідного CSV-файлу. Спочатку створюється тимчасовий файл, куди записуються результати обробки основного файлу. Команда sed видаляє перший рядок (зазвичай заголовок) та за допомогою регулярного виразу витягує назви груп із початку рядка, виділяючи перший фрагмент тексту до першого пробілу. 
	Далі перевіряється, чи перший рядок тимчасового файлу містить символ «-», який вказує на правильний формат назви групи. Якщо ця умова не виконується, функція повертає помилку. Після цього тимчасовий файл сортується і дублікати видаляються за допомогою команд sort та uniq, результат знову записується у тимчасовий файл. Наприкінці тимчасовий файл перейменовується у файл .group_list, що містить унікальний перелік груп для подальшого використання. Функція завершується з кодом успішного виконання.

146 groups=$(cat .group_list)
147
148 echo "Found groups in the file:"
149 echo "$groups"
150
151 if [[ -z "$groups" ]]; then
152 echo "No groups found in the file."
153 exit 1
154 fi

	Зчитується список груп з тимчасового файлу .group_list. Виводиться повідомлення з переліком знайдених груп. Якщо список порожній, виводиться помилка і скрипт завершує роботу.

156 if [[ -z "$selected_group" ]]; then
157  select_group
158 else
159 if ! grep -q "$selected_group" <<< "$groups"; then
160   echo "Error: Group '$selected_group' not found in the file!"
161  exit 1
162  fi
163 fi

	Якщо група не була передана як аргумент, викликається функція select_group для вибору групи користувачем. Якщо група вже вибрана, перевіряється, чи є вона у списку знайдених груп. Якщо групи немає у списку, виводиться помилка і робота припиняється.

39 select_group() {
40 echo "Select a group (or type 'Quit' to exit):"
41 select selected_group in $groups "Quit"; do
42 if [[ "$selected_group" == "Quit" ]]; then
43    echo "Exiting..."
44    exit 0
45  elif [[ -n "$selected_group" ]]; then
46    break
47  else
48    echo "Invalid choice, please try again."
49  fi
50 done
51 }


	Функція select_group відповідає за вибір групи користувачем із наявного списку. Вона виводить на екран запрошення обрати групу або вийти з програми, ввівши "Quit". Використовується конструкція select, яка створює меню з доступних груп, а також опції "Quit". Якщо користувач вибирає "Quit", скрипт виводить повідомлення про вихід і завершує роботу з кодом 0. Якщо вибір є дійсним (непорожнім), цикл припиняється і вибрана група зберігається для подальшого використання. У випадку недійсного вибору виводиться повідомлення про помилку, і користувача знову просять зробити вибір. Таким чином функція забезпечує інтуїтивний і безпечний спосіб вибору групи.

170 OUTPUT_FILE="$script_dir/Google_$(basename "$selected_file")"
171 echo "group: $selected_group"
172 echo "Input file: $INPUT_FILE"
173 echo "Output file: $OUTPUT_FILE"
174
175 generate_output_csv

	Формується ім’я вихідного файлу, який буде створено з префіксом Google_ у директорії скрипта. Виводяться параметри вибраної групи, вхідного та вихідного файлів для інформування користувача. Після цього запускається функція generate_output_csv, яка генерує кінцевий CSV-файл для подальшого використання.
	Функція generate_output_csv відповідає за створення вихідного CSV-файлу з розкладом у потрібному форматі. Спочатку у файл записується заголовок із назвами колонок: предмет, дата початку, час початку, дата кінця, час кінця та опис.
	Далі оголошується асоціативний масив для підрахунку кількості занять з кожного предмету, що дозволяє нумерувати повторювані предмети.
За допомогою команди awk здійснюється обробка вхідного файлу. У цьому блоці встановлюється патерн розбиття рядка на поля, який коректно розпізнає значення, навіть якщо вони взяті в лапки. Пропускається перший рядок, оскільки він містить заголовки.
	Для кожного рядка видаляються початкові та кінцеві лапки з полів. Якщо перше поле починається з назви вибраної групи, то обробляється інформація про заняття: витягується назва предмету, підраховується кількість його появ, і формується унікальна назва з номером.
	Дати початку і кінця переформатовуються зі стандартного формату дд.мм.рррр у формат мм/дд/рррр, який потрібен для сумісності з іншими системами.
	Часи початку і кінця конвертуються з 24-годинного формату в 12-годинний із позначками AM або PM. При цьому враховуються випадки півночі і полудня.
Всі оброблені дані формуються у рядок CSV і додаються до вихідного файлу.
Після завершення запису виводиться повідомлення про успішне створення файлу з вказанням його шляху.


4 ВИСНОВКИ
  Під час виконання лабораторної роботи я набула практичних навичок роботи з Bash-скриптами для обробки текстових файлів, зокрема CSV-формату. Я навчилася використовувати команди select, awk, sort, uniq, sed, iconv та інші для автоматизації вибору файлів, обробки розкладу занять та формування даних у формат, сумісний із Google Календарем. Особливу увагу було приділено роботі з текстовими кодуваннями, перетворенню дат і часу, а також обробці помилок, що покращило моє розуміння роботи системних команд у Linux. 

